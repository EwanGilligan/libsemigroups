//
// libsemigroups - C++ library for semigroups and monoids
// Copyright (C) 2016-18 James D. Mitchell
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

//! \file
//!
//! This file contains a declaration of the class template FroidurePin which
//! implements the Froidure-Pin algorithm as described in [Algorithms for
//! computing finite semigroups](https://www.irif.fr/~jep/PDF/Rio.pdf)
//!
//! For technical reasons the implementation of the methods of the FroidurePin
//! class template is contained in include/froidure-pin-impl.hpp.

// TODO(now)
// 1. Update the doc

#ifndef LIBSEMIGROUPS_INCLUDE_FROIDURE_PIN_HPP_
#define LIBSEMIGROUPS_INCLUDE_FROIDURE_PIN_HPP_

#include <stddef.h>  // for size_t

#include <iterator>       // for reverse_iterator
#include <mutex>          // for mutex
#include <thread>         // for get_id
#include <type_traits>    // for is_const, remove_pointer
#include <unordered_map>  // for unordered_map
#include <utility>        // for pair
#include <vector>         // for vector

#include "adapters.hpp"           // for complexity, degree, increase_degree_by
#include "constants.hpp"          // for UNDEFINED, LIMIT_MAX
#include "containers.hpp"         // for RecVec
#include "froidure-pin-base.hpp"  // for FroidurePinBase, FroidurePinBase::s...
#include "iterator.hpp"           // for iterator_base
#include "libsemigroups-config.hpp"     // for LIBSEMIGROUPS_DENSEHASHMAP
#include "libsemigroups-debug.hpp"      // for LIBSEMIGROUPS_ASSERT
#include "libsemigroups-exception.hpp"  // for LIBSEMIGROUPS_EXCEPTION
#include "report.hpp"                   // for REPORT
#include "stl.hpp"                      // for equal_to, hash
#include "timer.hpp"                    // for internal::Timer
#include "traits.hpp"                   // for TraitsHashEqual
#include "types.hpp"                    // for letter_type, word_type

#ifdef LIBSEMIGROUPS_DENSEHASHMAP
#include "extern/sparsehash-c11/sparsehash/dense_hash_map"
#endif

//! Namespace for everything in the libsemigroups library.
namespace libsemigroups {
  // Forward declaration
  class Element;

  //! Class for semigroups generated by instances of Element.
  //!
  //! FroidurePins are defined by a generating set, and the main method here is
  //! FroidurePin::enumerate, which implements the
  //! [Froidure-Pin Algorithm](https://www.irif.fr/~jep/PDF/Rio.pdf).
  //! When the enumeration of the semigroup is complete, the size, the left and
  //! right Cayley graphs are determined, and a confluent terminating
  //! presentation for the semigroup is known.
  template <typename TElementType  = Element const*,
            typename TElementHash  = internal::hash<TElementType>,
            typename TElementEqual = internal::equal_to<TElementType>,
            class TTraits
            = TraitsHashEqual<TElementType, TElementHash, TElementEqual>>
  class FroidurePin : private TTraits, public FroidurePinBase {
   private:
    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - typedefs - private
    ////////////////////////////////////////////////////////////////////////

    using internal_element_type = typename TTraits::internal_element_type;
    using internal_const_element_type =
        typename TTraits::internal_const_element_type;
    using internal_const_reference = typename TTraits::internal_const_reference;

    using internal_equal_to = typename TTraits::internal_equal_to;
    using internal_hash     = typename TTraits::internal_hash;

    using complexity      = ::libsemigroups::complexity<internal_element_type>;
    using internal_degree = ::libsemigroups::degree<internal_element_type>;
    using increase_degree_by
        = ::libsemigroups::increase_degree_by<internal_element_type>;
    using less    = ::libsemigroups::less<internal_element_type>;
    using one     = ::libsemigroups::one<internal_element_type>;
    using product = ::libsemigroups::product<internal_element_type>;
    using swap    = ::libsemigroups::swap<internal_element_type>;

    static_assert(
        std::is_const<internal_const_element_type>::value
            || std::is_const<typename std::remove_pointer<
                   internal_const_element_type>::type>::value,
        "internal_const_element_type must be const or pointer to const");

    // The elements of a semigroup are stored in _elements, but because of the
    // way add_generators/closure work, it might not be the case that all the
    // words of a given length are contiguous in _elements. Hence we require a
    // means of finding the next element of a given length. In
    // _enumerate_order, the first K_1 values are element_index_type's
    // equal to the positions in _elements of the words of length 1,
    // the next K_2 values are the element_index_type's equal to the positions
    // in _elements of the words of length 2, and so on.
    //
    // This alias is used to distinguish variables that refer to positions in
    // _elements (element_index_type) from those that refer to positions in
    // _enumerate_order (enumerate_index_type).
    using enumerate_index_type = FroidurePinBase::size_type;

   public:
    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - typedefs - public
    ////////////////////////////////////////////////////////////////////////

    using element_type       = typename TTraits::element_type;
    using const_element_type = typename TTraits::const_element_type;
    using const_reference    = typename TTraits::const_reference;
    using const_pointer      = typename TTraits::const_pointer;
    using size_type          = FroidurePinBase::size_type;
    using element_index_type = FroidurePinBase::element_index_type;

    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - constructors + destructor - public
    ////////////////////////////////////////////////////////////////////////

    //! Deleted.
    //!
    //! The FroidurePin class does not support an assignment contructor to avoid
    //! accidental copying. An object in FroidurePin may use many gigabytes of
    //! memory and might be extremely expensive to copy. A copy constructor is
    //! provided in case such a copy should it be required anyway.
    FroidurePin& operator=(FroidurePin const& semigroup) = delete;

    //! Construct from generators.
    //!
    //! This is the default constructor for a semigroup generated by \p gens.
    //! The generators \p gens must all be of the same derived subclass of the
    //! Element base class. Additionally, \p gens must satisfy the following:
    //!
    //! 1. there must be at least one generator
    //! 2. the generators must have equal degree Element::degree
    //! if either of these points is not satisfied, then a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.
    //!
    //! There can be duplicate generators and although they do not count as
    //! distinct elements, they do count as distinct generators. In other words,
    //! the generators of the semigroup are precisely (a copy of) \p gens in the
    //! same order they occur in \p gens.
    //!
    //! The generators \p gens are copied by the constructor, and so it is the
    //! responsibility of the caller to delete \p gens.
    explicit FroidurePin(std::vector<element_type> const*);

    //! Construct from generators.
    //!
    //! This constructor simply calls the above constructor with a pointer to \p
    //! gens.
    explicit FroidurePin(std::vector<element_type> const&);

    //! Construct from generators.
    //!
    //! This constructor simply constructs a vector from \p gens and calls the
    //! above constructor.
    explicit FroidurePin(std::initializer_list<element_type>);

    //! Copy constructor.
    //!
    //! Constructs a new FroidurePin which is an exact copy of \p copy. No
    //! enumeration is triggered for either \p copy or of the newly constructed
    //! semigroup.
    FroidurePin(FroidurePin const&);

    //! A default destructor.
    ~FroidurePin();

   private:
    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - constructor - private
    ////////////////////////////////////////////////////////////////////////

    FroidurePin(FroidurePin const&, std::vector<element_type> const*);

   public:
    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - settings - public
    ////////////////////////////////////////////////////////////////////////

    //! Set a new value for the batch size.
    //!
    //! The *batch size* is the number of new elements to be found by any call
    //! to FroidurePin::enumerate. A call to enumerate returns between 0 and
    //! approximately the batch size.
    //!
    //! The default value of the batch size is 8192.
    //!
    //! This is used by, for example, FroidurePin::position so that it is
    //! possible to find the position of an element without fully enumerating
    //! the semigroup.
    void set_batch_size(size_t) noexcept override;

    //! Returns the current value of the batch size. This is the minimum
    //! number of elements enumerated in any call to FroidurePin::enumerate.
    size_t batch_size() const noexcept override;

    //! Set the maximum number of threads that any method of an instance of
    //! FroidurePin can use.
    //!
    //! This method sets the maximum number of threads to be used by any method
    //! of a FroidurePin object. The number of threads is limited to the maximum
    //! of 1 and the minimum of \p nr_threads and the number of threads
    //! supported by the hardware.
    void set_max_threads(size_t) noexcept override;

    //! Returns the current value of
    size_t max_threads() const noexcept override;

    //! Returns the current value of
    void set_concurrency_threshold(size_t) noexcept override;

    //! Returns the current value of
    size_t concurrency_threshold() const noexcept override;

    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - methods - public
    ////////////////////////////////////////////////////////////////////////

    //! Returns the position in the semigroup corresponding to the element
    //! represented by the word \p w.
    //!
    //! The parameter \p w must consist of non-negative integers less than
    //! FroidurePin::nr_generators, or a LibsemigroupsException will be thrown.
    //! This method returns the position in \c this of the element obtained by
    //! evaluating \p w. This method does not perform any enumeration of the
    //! semigroup, and will return UNDEFINED if the position of the element of
    //! \c this corresponding to \p w cannot be determined.
    //!
    //! This is equivalent to finding the product \c x of the
    //! generators FroidurePin::gens(\c w[i]) and then calling
    //! FroidurePin::position_current with argument \c x.
    //!
    //! \sa FroidurePin::word_to_element.
    element_index_type word_to_pos(word_type const&) const override;

    //! Returns a copy of the element of \c this represented by the word
    //! \p w.
    //!
    //! The parameter \p w must consist of non-negative integers less than
    //! FroidurePin::nrgens, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method returns a copy of the element of \c this obtained by
    //! evaluating \p w. This is equivalent to finding the product \c x of the
    //! generators FroidurePin::gens(\c w[i]).
    //!
    //! A copy is returned instead of a reference, because the element of \c
    //! this corresponding to \p w may not yet have been enumerated.
    //!
    //! \sa FroidurePin::word_to_pos.
    element_type word_to_element(word_type const&) const;

    //! Returns \c true if the parameters represent the same element of the
    //! semigroup and \c false otherwise.
    bool equal_to(word_type const&, word_type const&) const override;

    //! Returns the maximum length of a word in the generators so far computed.
    //!
    //! Every elements of the semigroup can be expressed as a product of the
    //! generators. The elements of the semigroup are enumerated in the
    //! short-lex order induced by the order of the generators (as passed to
    //! FroidurePin::FroidurePin).  This method returns the length of the
    //! longest word in the generators that has so far been enumerated.
    size_t current_max_word_length() const noexcept override;

    //! Returns the degree of any (and all) Element's in the semigroup.
    size_t degree() const noexcept override;

    //! Returns the number of generators of the semigroup.
    size_t nr_generators() const noexcept override;

    //! Returns a const reference to the generator with index \p pos.
    //!
    //! If \p pos is not less than FroidurePin::nr_generators(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown. Note that FroidurePin::gens(pos)
    //! is in general in general not in position \p pos in the semigroup, i.e.
    //! is not equal to FroidurePin::at(pos).
    const_reference generator(letter_type) const;



    //! Returns the position of the element \p x in the semigroup if it is
    //! already known to belong to the semigroup.
    //!
    //! This method finds the position of the element \p x in the semigroup if
    //! it is already known to belong to the semigroup, and
    //! libsemigroups::FroidurePin::UNDEFINED if not. If the semigroup is
    //! not fully enumerated, then this method may return
    //! libsemigroups::FroidurePin::UNDEFINED when \p x is in the semigroup,
    //! but this is not yet known.
    //!
    //! \sa FroidurePin::position and FroidurePin::sorted_position.
    element_index_type current_position(const_reference x) const;

    //! Returns the number of elements in the semigroup that have been
    //! enumerated so far.
    //!
    //! This is only the actual size of the semigroup if the semigroup is fully
    //! enumerated.
    size_t current_size() const noexcept override;

    //! Returns the number of relations in the presentation for the semigroup
    //! that have been found so far.
    //!
    //! This is only the actual number of relations in a presentation defining
    //! the semigroup if the semigroup is fully enumerated.
    size_t current_nr_rules() const noexcept override;

    //! Returns the position of the prefix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    element_index_type prefix(element_index_type pos) const override;

    //! Returns the position of the suffix of the element \c x in position
    //! \p pos (of the semigroup) of length one less than the length of \c x.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    element_index_type suffix(element_index_type pos) const override;

    //! Returns the first letter of the element in position \p pos.
    //!
    //! This method returns the first letter of the element in position \p pos
    //! of the semigroup, which is the index of the generator corresponding to
    //! the first letter of the element.
    //!
    //! Note that FroidurePin::gens[FroidurePin::first_letter(\c pos)] is only
    //! equal to FroidurePin::at(FroidurePin::first_letter(\c pos)) if there are
    //! no duplicate generators.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    letter_type first_letter(element_index_type pos) const override;

    //! Returns the last letter of the element in position \p pos.
    //!
    //! This method returns the final letter of the element in position \p pos
    //! of the semigroup, which is the index of the generator corresponding to
    //! the final letter of the element.
    //!
    //! Note that FroidurePin::gens[FroidurePin::final_letter(\c pos)] is only
    //! equal to FroidurePin::at(FroidurePin::final_letter(\c pos)) if there are
    //! no duplicate generators.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    letter_type final_letter(element_index_type pos) const override;

    //! Returns the length of the element in position \c pos of the semigroup.
    //!
    //! The parameter \p pos must be a valid position of an already enumerated
    //! element of the semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method causes no enumeration of the semigroup.
    size_t length_const(element_index_type) const override;

    //! Returns the length of the element in position \c pos of the semigroup.
    //!
    //! The parameter \p pos must be a valid position of an element of the
    //! semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    size_t length_non_const(element_index_type) override;

    //! Returns the position in \c this of the product of \c this->at(i) and
    //! \c this->at(j) by following a path in the Cayley graph.
    //!
    //! The values \p i and \p j must be less than FroidurePin::current_size, or
    //! a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method returns the position FroidurePin::element_index_type in the
    //! semigroup of the product of \c this->at(i) and \c this->at(j) elements
    //! by following the path in the right Cayley graph from \p i labelled by
    //! the word \c this->minimal_factorisation(j) or, if
    //! this->minimal_factorisation(i) is shorter, by following the path in the
    //! left Cayley graph from \p j labelled by this->minimal_factorisation(i).
    element_index_type product_by_reduction(element_index_type,
                                            element_index_type) const override;

    //! Returns the position in \c this of the product of \c this->at(i) and
    //! \c this->at(j).
    //!
    //! The values \p i and \p j must be less than FroidurePin::current_size, or
    //! a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method either:
    //!
    //! * follows the path in the right or left Cayley graph from \p i to \p j,
    //!   whichever is shorter using FroidurePin::product_by_reduction; or
    //!
    //! * multiplies the elements in postions \p i and \p j together;
    //!
    //! whichever is better. The method used is determined by comparing
    //! Element::complexity and the FroidurePin::length_const of \p i and \p j.
    //!
    //! For example, if the Element::complexity of the multiplication is linear
    //! and \c this is a semigroup of transformations of degree 20, and the
    //! shortest paths in the left and right Cayley graphs from \p i to \p j
    //! are of length 100 and 1131, then it better to just product the
    //! transformations together.
    element_index_type fast_product(element_index_type,
                                    element_index_type) const override;

    //! Returns the position in \c this of the generator with index \p i
    //!
    //! If \p i is not a valid generator index, a LIBSEMIGROUPS_EXCEPTION will
    //! be thrown. In many cases \p letter_to_pos(i) will equal \p i, examples
    //! of when this will not be the case are:
    //!
    //! * there are duplicate generators;
    //!
    //! * FroidurePin::add_generators was called after the semigroup was already
    //! partially enumerated.
    element_index_type letter_to_pos(letter_type) const override;

    //! Returns the total number of idempotents in the semigroup.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.  The value of the positions, and number, of
    //! idempotents is stored after they are first computed.
    size_t nr_idempotents() override;

    //! Returns \c true if the element in position \p pos is an idempotent
    //! and \c false if it is not.
    //!
    //! The parameter \p pos must be a valid position of an element of the
    //! semigroup, or a LIBSEMIGROUPS_EXCEPTION will be thrown.
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.
    bool is_idempotent(element_index_type) override;

    //! Returns the total number of relations in the presentation defining the
    //! semigroup.
    //!
    //! \sa FroidurePin::next_relation.
    size_t nr_rules() override;

    //! Requests that the capacity (i.e. number of elements) of the semigroup
    //! be at least enough to contain n elements.
    //!
    //! The parameter \p n is also used to initialise certain data members, if
    //! you know a good upper bound for the size of your semigroup, then it is
    //! a good idea to call this method with that upper bound as an argument,
    //! this can significantly improve the performance of the
    //! FroidurePin::enumerate method, and consequently every other method too.
    void reserve(size_t) override;

    //! Returns the size of the semigroup.
    size_t size() override;

    //! Returns \c true if \p x is an element of \c this and \c false if it is
    //! not.
    //!
    //! This method can be used to check if the element \p x is an element of
    //! the semigroup. The semigroup is enumerated in batches until \p x is
    //! found or the semigroup is fully enumerated but \p x was not found (see
    //! FroidurePin::set_batch_size).
    bool contains(const_reference);

    //! Returns the position of \p x in \c this, or FroidurePin::UNDEFINED if \p
    //! x is not an element of \c this.
    //!
    //! This method can be used to find the FroidurePin::element_index_type
    //! position of the element \p x if it belongs to the semigroup. The
    //! semigroup is enumerated in batches until \p x is found or the semigroup
    //! is fully enumerated but \p x was not found (see
    //! FroidurePin::set_batch_size).
    element_index_type position(const_reference);

    //! Returns the position of \p x in the sorted array of elements of the
    //! semigroup, or FroidurePin::UNDEFINED if \p x is not an element of \c
    //! this.
    element_index_type sorted_position(const_reference);

    //! Returns the position of \c this->at(pos) in the sorted array of
    //! elements of the semigroup, or FroidurePin::UNDEFINED if \p pos is
    //! greater than the size of the semigroup.
    element_index_type position_to_sorted_position(element_index_type) override;

    //! Returns  the element of the semigroup in position \p pos, or a
    //! \c nullptr if there is no such element.
    //!
    //! This method attempts to enumerate the semigroup until at least
    //! \c pos + 1 elements have been found. If \p pos is greater than
    //! FroidurePin::size, then this method returns \c nullptr.
    const_reference at(element_index_type);

    //! Returns the element of the semigroup in position \p pos.
    //!
    //! This method performs no checks on its argument, and performs no
    //! enumeration of the semigroup.
    const_reference operator[](element_index_type) const;

    //! Returns the element of the semigroup in position \p pos of the sorted
    //! array of elements, or \c nullptr in \p pos is not valid (i.e. too big).
    //!
    //! This method fully enumerates the semigroup.
    const_reference sorted_at(element_index_type);

    //! Returns the index of the product of the element in position \p i with
    //! the generator with index \p j.
    //!
    //! This method fully enumerates the semigroup.
    element_index_type right(element_index_type, letter_type) override;

    //! Returns the index of the product of the generator with index \p j and
    //! the element in position \p i.
    //!
    //! This method fully enumerates the semigroup.
    element_index_type left(element_index_type, letter_type) override;

    //! Changes \p word in-place to contain a minimal word with respect to the
    //! short-lex ordering in the generators equal to the \p pos element of
    //! the semigroup.
    //!
    //! If \p pos is less than the size of this semigroup, then this method
    //! changes its first parameter \p word in-place by first clearing it and
    //! then to contain a minimal factorization of the element in position \p
    //! pos of the semigroup with respect to the generators of the semigroup.
    //! This method enumerates the semigroup until at least the \p pos element
    //! is known. If \p pos is greater than the size of the semigroup, then
    //! a LIBSEMIGROUPS_EXCEPTION is thrown.
    void minimal_factorisation(word_type&, element_index_type) override;

    //! Returns a minimal libsemigroups::word_type which evaluates to the
    //! Element in position \p pos of \c this.
    //!
    //! This is the same as the two-argument method for
    //! FroidurePin::minimal_factorisation, but it returns a pointer to the
    //! factorisation instead of modifying an argument in-place.
    //! If \p pos is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    word_type minimal_factorisation(element_index_type) override;

    //! Returns a minimal libsemigroups::word_type which evaluates to \p x.
    //!
    //! This is the same as the method taking a FroidurePin::element_index_type,
    //! but it factorises an Element instead of using the position of an
    //! element. If \p pos is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    word_type minimal_factorisation(const_reference);

    //! Changes \p word in-place to contain a word in the generators equal to
    //! the \p pos element of the semigroup.
    //!
    //! The key difference between this method and
    //! FroidurePin::minimal_factorisation(word_type& word, element_index_type
    //! pos), is that the resulting factorisation may not be minimal. If \p pos
    //! is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    void factorisation(word_type&, element_index_type) override;

    //! Returns a libsemigroups::word_type which evaluates to the Element in
    //! position \p pos of \c this.
    //!
    //! The key difference between this method and
    //! FroidurePin::minimal_factorisation(element_index_type pos), is that the
    //! resulting factorisation may not be minimal.
    //! If \p pos is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    word_type factorisation(element_index_type pos) override;

    //! Returns a libsemigroups::word_type which evaluates to \p x.
    //!
    //! The key difference between this method and
    //! FroidurePin::minimal_factorisation(const_reference x), is that the
    //! resulting factorisation may not be minimal.
    //! If \p pos is greater than the size of the semigroup, then a
    //! LIBSEMIGROUPS_EXCEPTION is thrown.
    word_type factorisation(const_reference);

    //! This method resets FroidurePin::next_relation so that when it is next
    //! called the resulting relation is the first one.
    //!
    //! After a call to this function, the next call to
    //! FroidurePin::next_relation will return the first relation of the
    //! presentation defining the semigroup.
    void reset_next_relation() noexcept override;

    //! This method changes \p relation in-place to contain the next relation
    //! of the presentation defining \c this.
    //!
    //! This method changes \p relation in-place so that one of the following
    //! holds:
    //!
    //! * \p relation is a vector consisting of a libsemigroups::letter_type and
    //! a libsemigroups::letter_type such that FroidurePin::gens(\c relation[\c
    //! 0]) == FroidurePin::gens(\c relation[\c 1]), i.e. if the semigroup was
    //! defined with duplicate generators;
    //!
    //! * \p relation is a vector consisting of a
    //! libsemigroups::element_index_type, libsemigroups::letter_type, and
    //! libsemigroups::element_index_type such that
    //! \code{.cpp}
    //!   this[relation[0]] * FroidurePin::gens(relation[1]) ==
    //!   this[relation[2]]
    //! \endcode
    //!
    //! * \p relation is empty if there are no more relations.
    //!
    //! FroidurePin::next_relation is guaranteed to output all relations of
    //! length 2 before any relations of length 3. If called repeatedly after
    //! FroidurePin::reset_next_relation, and until relation is empty, the
    //! values placed in \p relation correspond to a length-reducing confluent
    //! rewriting system that defines the semigroup.
    //!
    //! This method can be used in conjunction with FroidurePin::factorisation
    //! to obtain a presentation defining the semigroup.
    //!
    //! \sa FroidurePin::reset_next_relation.
    void next_relation(word_type& relation) override;

    //! Enumerate the semigroup until \p limit elements are found or \p killed
    //! is \c true.
    //!
    //! This is the main method of the FroidurePin class, where the
    //! Froidure-Pin Algorithm is implemented.
    //!
    //! If the semigroup is already fully enumerated, or the number of elements
    //! previously enumerated exceeds \p limit, then calling this method does
    //! nothing. Otherwise, enumerate attempts to find at least the maximum of
    //! \p limit and FroidurePin::batch_size elements of the semigroup. If \p
    //! killed is set to \c true (usually by another process), then the
    //! enumeration is terminated as soon as possible.  It is possible to
    //! resume enumeration at some later point after any call to this method,
    //! even if it has been killed.
    //!
    //! If the semigroup is fully enumerated, then it knows its left and right
    //! Cayley graphs, and a minimal factorisation of every element (in terms of
    //! its generating set).  All of the elements are stored in memory until the
    //! object is destroyed.
    //!
    //! The parameter \p limit defaults to FroidurePin::LIMIT_MAX.
    void enumerate(size_t = LIMIT_MAX) override;
    void run() override;
    void run(size_t);

    //! Add copies of the generators \p coll to the generators of \c this.
    //!
    //! This method can be used to add new generators to the existing semigroup
    //! in such a way that any previously enumerated data is preserved and not
    //! recomputed, or copied. This can be faster than recomputing the semigroup
    //! generated by the old generators and the new generators in the parameter
    //! \p coll.
    //!
    //! This method changes the semigroup in-place, thereby invalidating
    //! possibly previously known data about the semigroup, such as the left or
    //! right Cayley graphs, number of idempotents, and so on.
    //!
    //! Every generator in \p coll is added regardless of whether or not it is
    //! already a generator or element of the semigroup (it may belong to the
    //! semigroup but just not be known to belong). If \p coll is empty, then
    //! the semigroup is left unchanged. The order the generators is added is
    //! also the order they occur in the parameter \p coll.
    //!
    //! The semigroup is returned in a state where all of the previously
    //! enumerated elements which had been multiplied by all of the old
    //! generators, have now been multiplied by all of the old and new
    //! generators. This means that after this method is called the semigroup
    //! might contain many more elements than before (whether it is fully
    //! enumerating or not).  It can also be the case that the new generators
    //! are the only new elements, unlike, say, in the case of non-trivial
    //! groups.
    //!
    //! The elements of the argument \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    //! If an element in \p coll has a degree different to \c this->degree(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.

    void add_generator(element_type const&);

    template <class TCollection>
    void add_generators(TCollection const&);

    //! Add copies of the generators \p coll to the generators of \c this.
    //!
    //! See FroidurePin::add_generators for more details.
    void add_generators(std::initializer_list<const_element_type>);

    //! Returns a new semigroup generated by \c this and \p coll.
    //!
    //! This method is equivalent to copying \c this using
    //! FroidurePin::FroidurePin(const FroidurePin& copy) and then calling
    //! FroidurePin::add_generators on the copy, but this method avoids copying
    //! the parts of \c this that are immediately invalidated by
    //! FroidurePin::add_generators.
    //!
    //! The elements the argument \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    //! If an element in \p coll has a degree different to \c this->degree(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.
    template <class TCollection>
    FroidurePin* copy_add_generators(TCollection const&) const;

    //! Add copies of the non-redundant generators in \p coll to the generators
    //! of \c this.
    //!
    //! This method can be used to add new generators to an existing semigroup
    //! in such a way that any previously enumerated data is preserved and not
    //! recomputed, or copied. This can be faster than recomputing the semigroup
    //! generated by the old generators and the new in \p coll.
    //!
    //! This method differs from FroidurePin::add_generators in that it tries to
    //! add the new generators one by one, and only adds those generators that
    //! are not products of existing generators (including any new generators
    //! from \p coll that were added before). The generators are added in the
    //! order they occur in \p coll.
    //!
    //! This method changes the semigroup in-place, thereby
    //! invalidating possibly previously known data about the semigroup, such as
    //! the left or right Cayley graphs, or number of idempotents, for example.
    //!
    //! The elements the parameter \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    //! If an element in \p coll has a degree different to \c this->degree(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.
    template <class TCollection>
    void closure(TCollection const& coll);

    //! Add copies of the non-redundant generators in \p coll to the
    //! generators of \c this.
    //!
    //! See FroidurePin::closure for more details.
    void closure(std::initializer_list<const_element_type>);

    //! Returns a new semigroup generated by \c this and copies of the
    //! non-redundant elements of \p coll.
    //!
    //! This method is equivalent to copying \c this and then calling
    //! FroidurePin::closure on the copy with \p coll, but this method avoids
    //! copying the parts of \c this that are immediately invalidated by
    //! FroidurePin::closure.
    //!
    //! The elements the argument \p coll are copied into the semigroup, and
    //! should be deleted by the caller.
    //! If an element in \p coll has a degree different to \c this->degree(), a
    //! LIBSEMIGROUPS_EXCEPTION will be thrown.
    template <class TCollection>
    FroidurePin* copy_closure(TCollection const&);

    bool is_monoid() override;

   private:
    ////////////////////////////////////////////////////////////////////////
    // Runner - non-pure virtual member functions - private
    ////////////////////////////////////////////////////////////////////////
    bool started_impl() const noexcept override;
    bool finished_impl() const override;

    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - validation methods - private
    ////////////////////////////////////////////////////////////////////////

    void validate_element_index(element_index_type) const;
    void validate_letter_index(letter_type) const;
    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - enumeration methods - private
    ////////////////////////////////////////////////////////////////////////

    inline void expand(size_type);
    inline void is_one(internal_const_element_type,
                       element_index_type) noexcept;
    void        copy_gens();
    void        closure_update(element_index_type,
                               letter_type,
                               letter_type,
                               element_index_type,
                               size_type,
                               size_t const&,
                               std::vector<bool>&);

    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - initialisation methods - private
    ////////////////////////////////////////////////////////////////////////

    using internal_idempotent_pair
        = std::pair<internal_element_type, element_index_type>;

    void init_sorted();
    void init_idempotents();
    void idempotents(enumerate_index_type const,
                     enumerate_index_type const,
                     enumerate_index_type const,
                     std::vector<internal_idempotent_pair>&);

    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - iterators - private
    ////////////////////////////////////////////////////////////////////////

    // Forward declarations - implemented in froidure-pin-impl.hpp
    struct iterator_methods;
    struct iterator_methods_pair_first;

    // A type for const iterators through (element, index) pairs of \c this.
    using const_iterator_pair_first = internal::iterator_base<
        std::pair<internal_element_type, element_index_type>,
        const_pointer,
        const_reference,
        element_type,
        iterator_methods_pair_first>;

    // A type for const reverse iterators through (element_type,
    // element_index_type) pairs of this.
    using const_reverse_iterator_pair_first
        = std::reverse_iterator<const_iterator_pair_first>;

   public:
    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - iterators - public
    ////////////////////////////////////////////////////////////////////////
    //! A type for const iterators through the elements of \c this, in the
    //! order they were enumerated (i.e. in short-lex order of the minimum word
    //! in the generators of \c this equal to any given element).
    //!
    //! \sa const_reverse_iterator.
    using const_iterator = internal::iterator_base<internal_element_type,
                                                   const_pointer,
                                                   const_reference,
                                                   element_type,
                                                   iterator_methods>;

    //! A type for const reverse iterators through the elements of \c this, in
    //! the reverse order of enumeration.
    //!
    //! \sa const_iterator.
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    //! A type for const iterators through the elements of \c this, sorted
    //! according to TTraits::less.
    //!
    //! \sa const_reverse_iterator_sorted.
    using const_iterator_sorted = const_iterator_pair_first;

    //! A type for const reverse iterators through the elements of \c this,
    //! sorted according to TTraits::less.
    //!
    //! \sa const_iterator_sorted.
    using const_reverse_iterator_sorted = const_reverse_iterator_pair_first;

    //! A type for const iterators through the idempotents of \c this, in
    //! short-lex order.
    //!
    //! \sa const_iterator.
    using const_iterator_idempotents = const_iterator_pair_first;

    //! A type for reverse const iterators through the idempotents of \c this,
    //! in short-lex order.
    //!
    //! \sa const_iterator_idempotents.
    using const_reverse_iterator_idempotents
        = const_reverse_iterator_pair_first;

    //! Returns a const iterator pointing to the first element of the
    //! semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the FroidurePin class.
    const_iterator cbegin() const;

    //! Returns a const iterator pointing to the first element of the
    //! semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the FroidurePin class.
    const_iterator begin() const;

    //! Returns a const iterator pointing to one past the last currently known
    //! element of the semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the FroidurePin class.
    const_iterator cend() const;

    //! Returns a const iterator pointing to one past the last currently known
    //! element of the semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the FroidurePin class.
    const_iterator end() const;

    //! Returns a const reverse iterator pointing to the last currently known
    //! element of the semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the FroidurePin class.
    const_reverse_iterator crbegin() const;

    //! Returns a const reverse iterator pointing to one before the first
    //! element of the semigroup.
    //!
    //! This method does not perform any enumeration of the semigroup, the
    //! iterator returned may be invalidated by any call to a non-const method
    //! of the FroidurePin class.
    const_reverse_iterator crend() const;

    //! Returns a const iterator pointing to the first element of the semigroup
    //! when the elements are sorted by Element::operator<.
    //!
    //! This method fully enumerates the semigroup, the returned iterator
    //! returned may be invalidated by any call to a non-const method of the
    //! FroidurePin class.
    const_iterator_sorted cbegin_sorted();

    //! Returns a const iterator pointing to one past the last element of the
    //! semigroup when the elements are sorted by Element::operator<.
    //!
    //! This method fully enumerates the semigroup, the returned iterator
    //! returned may be invalidated by any call to a non-const method of the
    //! FroidurePin class.
    const_iterator_sorted cend_sorted();

    //! Returns a const iterator pointing to the last element of the semigroup
    //! when the elements are sorted by Element::operator<.
    //!
    //! This method fully enumerates the semigroup, the returned iterator
    //! returned may be invalidated by any call to a non-const method of the
    //! FroidurePin class.
    const_reverse_iterator_sorted crbegin_sorted();

    //! Returns a const iterator pointing to one before the first element of
    //! the semigroup when the elements are sorted by Element::operator<.
    //!
    //! This method fully enumerates the semigroup, the returned iterator
    //! returned may be invalidated by any call to a non-const method of the
    //! FroidurePin class.
    const_reverse_iterator_sorted crend_sorted();

    //! Returns a const iterator pointing at the first idempotent in the
    //! semigroup.
    //!
    //! If the returned iterator is incremented, then it points to the second
    //! idempotent in the semigroup (if it exists), and every subsequent
    //! increment points to the next idempotent.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.
    const_iterator_idempotents cbegin_idempotents();

    //! Returns a const iterator referring to past the end of the last
    //! idempotent in the semigroup.
    //!
    //! This method involves fully enumerating the semigroup, if it is not
    //! already fully enumerated.
    const_iterator_idempotents cend_idempotents();

    ////////////////////////////////////////////////////////////////////////
    // FroidurePin - data - private
    ////////////////////////////////////////////////////////////////////////

    // Type for a left or right Cayley graph of a semigroup.
    using cayley_graph_type = internal::RecVec<element_index_type>;

    struct Settings {
      Settings();
      Settings(Settings const&) = default;
      size_t _batch_size;
      size_t _concurrency_threshold;
      size_t _max_threads;
    } _settings;

    size_t                                           _degree;
    std::vector<std::pair<letter_type, letter_type>> _duplicate_gens;
    std::vector<internal_element_type>               _elements;
    std::vector<element_index_type>                  _enumerate_order;
    std::vector<letter_type>                         _final;
    std::vector<letter_type>                         _first;
    bool                                             _found_one;
    std::vector<internal_element_type>               _gens;
    internal_element_type                            _id;
    std::vector<internal_idempotent_pair>            _idempotents;
    bool                                             _idempotents_found;
    std::vector<bool>                                _is_idempotent;
    cayley_graph_type                                _left;
    std::vector<size_type>                           _length;
    std::vector<enumerate_index_type>                _lenindex;
    std::vector<element_index_type>                  _letter_to_pos;
#ifdef LIBSEMIGROUPS_DENSEHASHMAP
    google::dense_hash_map<internal_const_element_type,
                           element_index_type,
                           internal_hash,
                           internal_equal_to>
        _map;
#else
    std::unordered_map<internal_const_element_type,
                       element_index_type,
                       internal_hash,
                       internal_equal_to>
        _map;
#endif
    mutable std::mutex              _mtx;
    size_type                       _nr;
    letter_type                     _nrgens;
    size_t                          _nr_rules;
    enumerate_index_type            _pos;
    element_index_type              _pos_one;
    std::vector<element_index_type> _prefix;
    internal::RecVec<bool>          _reduced;
    letter_type                     _relation_gen;
    enumerate_index_type            _relation_pos;
    cayley_graph_type               _right;
    std::vector<std::pair<internal_element_type, element_index_type>> _sorted;
    std::vector<element_index_type>                                   _suffix;
    mutable internal_element_type _tmp_product;
    size_t                        _wordlen;

#ifdef LIBSEMIGROUPS_STATS
    size_t _nr_products;
#endif
  };
}  // namespace libsemigroups

// Include the implementation of the member functions for FroidurePin
#include "froidure-pin-impl.hpp"
#endif  // LIBSEMIGROUPS_INCLUDE_FROIDURE_PIN_HPP_
